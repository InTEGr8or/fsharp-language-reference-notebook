#!markdown

# Web Page Scraping with Canopy

As far as I know, the only way to overcome AJAX-loaded data problem when scraping webpages is by using Selenium to control a web browser and use that to inspect the resultant DOM.

There might be some Node.js tools that mimick the browser JS engine, but I think I will try to call them from F# if I need to use anything like that.

## Choosing a Source

The F# Language Reference is presented on the MS Documentation webpage, which is stored in a GitHub repo, which is presented as a web repo, available as "raw content" through the web repo, and is clonable to a local repo which can be accessed through local file access with `System.IO`.

I like the whole "everything is local" idea of accessing the data through the GitHub repo, cloning it locally and accessing through file access. 

Microsoft has implemented the repo with a wiki-like syntax that looks like this:

```markdown
As an example, consider the following active pattern with an argument.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet5001.fs)]

You can use the active pattern in a pattern matching expression, as in the following example.

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-2/snippet5002.fs)]
```

So I had to decide weather to implement a sort of custom-web-local-hybrid scrape including wiki-lookups for code-snippets. It's a judgement call. I figured I would get more mileage from developing code and my skills in the direction of Canopy-enabled AJAX-capable HTTP web scraping. This also prevents users of this repo from having to clone the entire MS documentation repo in order to get what they want.

#!fsharp

#r "nuget: FSharp.Data, 4.0.1"
open FSharp.Data
#r "nuget: canopy, 2.1.5"
open canopy.runner.classic
open canopy.configuration
open canopy.classic
#r "nuget: Selenium.WebDriver.ChromeDriver, 91.0.4472.1900"
open System
open System.IO
open System.Text.RegularExpressions

#!markdown

You might need to to upgrade Chrome by opening Chrome and going to Settings > About Chrome, or going to:

[Google Chrome Web Browser](https://www.google.com/chrome/thank-you.html?statcb=1&installdataindex=empty&defaultbrowser=0)

## Load Constants and Open Browser Window

The rest of the code runs a lot quicker after the browswer is open, so it's nice to open it and then troubleshoot parsing.

#!fsharp

let LanguageRefUrl = "https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/"
let linksElements = "div.js-details-container.Details div.py-2 a.Link--primary"
let listSelector = "#title-7-1 > ul > li"
let expandSelector = ".tree-item"
let chromedriverDir = "C:/Users/xgenx/.nuget/packages/microsoft.dotnet-interactive/1.0.225602/tools/net5.0/any"

canopy.configuration.chromeDir <- chromedriverDir

//start an instance of chrome
let browser = start chrome
url LanguageRefUrl
// let content = read linksElements
let pageTitle = (fastTextFromCSS "title").[0].Split([|" | "|], StringSplitOptions.TrimEntries).[0].Replace("- ", "").Replace(" ", "_")
// pageTitle |> printf "Title: %A" 

#!fsharp

let hasAnchor element =
    match element |> someElementWithin "a" with
    | Some(_) -> true
    | None -> false

let followLink element = 
    element


let toc = element "#title-7-1 > ul" 
let tocItems = toc |> elementsWithin "li"
let folderItems = tocItems |> List.filter (fun item -> item.GetAttribute("class").IndexOf("tree-item") > -1) 

// Open folders
folderItems |> List.filter (fun folderItem -> folderItem.GetAttribute("class").Contains("is-expanded") = false) |> List.iter (fun item -> item |> elementWithin "span" |> click) 

let pageItems = tocItems |> List.filter (fun item -> item.GetAttribute("class").IndexOf("tree-item") = -1)
let pageLinks = pageItems |> List.map (fun item -> (item |> elementWithin "a").GetAttribute("href"))

#!fsharp

#r "nuget: ReverseMarkdown, 3.19.0"
open ReverseMarkdown

let converter = new Converter()

let readContents (pageLink:string) : List<IWebElement> =
    url pageLink
    waitForElement "h2#feedback"
    element "main#main.content" |> elementsWithin "div,h1,h2,pre,p"

let stripString (pattern:string) (replace:string) (content:string): string =
    // printf "CONTENT: %s" content.[(String.length content)..]
    let result = Regex.Replace(content, pattern, replace)
    // printf "RESULT: %s" result.[(String.length result)..]
    result

let htmlElementsToDib (elements:List<IWebElement>) : string =
    // elements |> List.iter (fun item -> Regex.Replace(item.GetProperty("outerHTML").Trim(), @"[\t\s]{2,500}", " ").[0..150] |> printf "Elements: %s")
    let markdownList:List<string> = elements |> List.map (fun element ->
        match element.GetAttribute("class").Contains("has-inner-focus") with
        | true -> "\n#!fsharp\n\n" + element.GetProperty("innerText") + "\n#!markdown\n\n"
        | false -> "\n\n" + converter.Convert(element.GetProperty("outerHTML")).Replace("</caption>","</caption>\n\n") + "\n\n"
    )
    let markdown = "#!markdown\n\n" + System.String.Join("\n", markdownList)
    // printf "%O" markdown
    markdown |> stripString @"[\t]{5,100}" " " |> stripString @"[\n\r]{3,500}" "\n\n" |> stripString """(F#|Console)<button[.\s\n\w\"=\-\<\>\/]*\<\/button\>""" ""

let writeContentsToFile (pageLink:string) =
    let mainContent:List<IWebElement> = readContents pageLink
    let snippetSelector = "code.lang-fsharp"
    let folder = pageLink.[pageLink.IndexOf("/language-reference/")+20..pageLink.LastIndexOf("/")]
    let folderPath = __SOURCE_DIRECTORY__ + "/" + if String.length folder > 0 then folder.Replace(" ", "_") + "/" else ""
    if not (Directory.Exists folderPath) then
        Directory.CreateDirectory folderPath |> ignore
        printfn "CREATING DIR: %O" folderPath

    let dibDocument = htmlElementsToDib mainContent
    // printf "dibDocument: %A" dibDocument
    let titleFromUrl = pageLink.[pageLink.LastIndexOf("/") + 1..]
    let outfile = folderPath + if (String.length titleFromUrl) > 0 then titleFromUrl else "_index"  + ".dib"
    printfn "Writing file: %s" (outfile)
    File.WriteAllText(outfile, dibDocument)

pageLinks |> List.iter (fun pageLink ->
    writeContentsToFile pageLink
)

#!fsharp

tocItems |> List.iter (fun element -> ( 
    if element.GetAttribute("class") = "tree-item" then (
        element |> elementWithin "span" |> click 
    ) else element |> elementsWithin("a") |> printf "%A" 
))

#!fsharp

Collections.ObjectModel.ReadOnlyCollection<OpenQA.Selenium.IWebElement>

let topics = HtmlDocument.Load(LanguageRefUrl).CssSelect(listSelector)

let links = topics |> List.map(fun a -> (a.AttributeValue("href")))

let rec ReadDocs links folder =
    for (link:string) in links do
        if link.Contains(".md") || link.Contains(".png") then
            let folderString = if String.length folder > 0 then folder + "/" else ""
            let folderPath = __SOURCE_DIRECTORY__ + folderString
            if not (Directory.Exists folderPath) then
                Directory.CreateDirectory folderPath |> ignore
                printfn "CREATING DIR: %O" folderPath
                    
            let document = Http.RequestString(RawFileRootUrl + link.Replace("blob/", ""))
            let titleStart = document.[document.IndexOf("title: ") + 7..200]
            let title = titleStart.[..titleStart.IndexOf("\n")]
            printfn "PRINTING TITLE: %s" title
            let dibDocument = $"#!markdown\n\n[{title}]({githubRootUrl + link})\n" + document.Replace("""```fsharp""", """#!fsharp\n""").Replace("""```""","""#!markdown\n""")
            let outfile = folderPath + link.[link.LastIndexOf("/") + 1..].Replace(".md", ".dib") 
            printfn "Writing file: %s\n\n%s\n\n" outfile dibDocument
            File.WriteAllText(outfile, dibDocument)
                
        else
            let folder = link.[link.LastIndexOf("/")..]
            let folderUrl = "https://github.com" + link
            printfn "Folder: %s " folderUrl
            let topics = HtmlDocument.Load(folderUrl).CssSelect(listSelector)
            let links = topics |> List.map(fun a -> (a.AttributeValue("href")))
            ReadDocs links.[0..2] folder
            // printfn "Error fetching: %s" link

ReadDocs links.[0..2] ""
