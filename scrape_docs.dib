#!fsharp

#r "nuget: FSharp.Data, 4.0.1"
open FSharp.Data
#r "nuget: canopy, 2.1.5"
open canopy.runner
open canopy.configuration
open canopy
#r "nuget: Selenium.WebDriver, 3.141.0"
#r "nuget: Selenium.WebDriver.ChromeDriver, 91.0.4472.1900"
open OpenQA.Selenium
open System.IO
open System.Text.RegularExpressions

#!markdown

You might need to to upgrade Chrome by opening Chrome and going to Settings > About Chrome, or going to:

[Google Chrome Web Browser](https://www.google.com/chrome/thank-you.html?statcb=1&installdataindex=empty&defaultbrowser=0)

#!fsharp

let LanguageRefUrl = "https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/"
let LanguageRefDocsUrl = "https://github.com/dotnet/docs/tree/main/docs/fsharp/language-reference"
let githubRootUrl = "https://github.com/"
let RawFileRootUrl = "https://raw.githubusercontent.com/"
let linksElements = "div.js-details-container.Details div.py-2 a.Link--primary"
let listSelector = "#title-7-1 > ul > li"
let expandSelector = ".tree-item"
let chromedriverDir = "C:/Users/xgenx/.nuget/packages/microsoft.dotnet-interactive/1.0.225602/tools/net5.0/any"

canopy.configuration.chromeDir <- chromedriverDir

//start an instance of chrome
let browser = start chrome
url LanguageRefUrl
// let content = read linksElements
let title = (fastTextFromCSS "title").[0].Split([|" | "|], StringSplitOptions.TrimEntries).[0]
title |> printf "Title: %A" 

#!fsharp

let hasAnchor element =
    match element |> someElementWithin "a" with
    | Some(_) -> true
    | None -> false

// let hasExpand (element: Selenium.IWebElement) =
//     let classes = element.GetAttribute("class")
//     match classes with
//     | Some(_) -> true
//     | None -> false

let followLink element = 
    element


let toc = element "#title-7-1 > ul" 
let tocItems = toc |> elementsWithin "li"
let folderItems = tocItems |> List.filter (fun item -> item.GetAttribute("class").IndexOf("tree-item") > -1) 
let pageItems = tocItems |> List.filter (fun item -> item.GetAttribute("class").IndexOf("tree-item") = -1)
// let pageLinks = List.map (fun item -> item |)
folderItems |> List.iter (fun item -> item |> elementWithin "span" |> click) 
let pageLinks = pageItems |> List.map (fun item -> (item |> elementWithin "a").GetAttribute("href"))

#!fsharp

url pageLinks.[8]
let mainContent = elements "main#main.content code.lang-fsharp"
printf "%s" (mainContent.[3].GetProperty("innerText"))
// mainContent |> List.iter (fun pre -> pre.GetProperty("innterHTML") |> printf "%s")
// mainContent.GetProperty("children") 
//     |> List.filter (fun child -> child.GetProperty("innerHTML").indexOf("<pre>") > -1) 
//     |> List.iter (fun pre -> printf ("%A" (pre.GetProperty("innerText")))) 

#!fsharp

tocItems |> List.iter (fun element -> ( 
    if element.GetAttribute("class") = "tree-item" then (
        element |> elementWithin "span" |> click 
    ) else element |> elementsWithin("a") |> printf "%A" 
))

#!fsharp

Collections.ObjectModel.ReadOnlyCollection<OpenQA.Selenium.IWebElement>

let topics = HtmlDocument.Load(LanguageRefUrl).CssSelect(listSelector)

let links = topics |> List.map(fun a -> (a.AttributeValue("href")))

let rec ReadDocs links folder =
    for (link:string) in links do
        if link.Contains(".md") || link.Contains(".png") then
            let folderString = if String.length folder > 0 then folder + "/" else ""
            let folderPath = __SOURCE_DIRECTORY__ + folderString
            if not (Directory.Exists folderPath) then
                Directory.CreateDirectory folderPath |> ignore
                printfn "CREATING DIR: %O" folderPath
                    
            let document = Http.RequestString(RawFileRootUrl + link.Replace("blob/", ""))
            let titleStart = document.[document.IndexOf("title: ") + 7..200]
            let title = titleStart.[..titleStart.IndexOf("\n")]
            printfn "PRINTING TITLE: %s" title
            let dibDocument = $"#!markdown\n\n[{title}]({githubRootUrl + link})\n" + document.Replace("""```fsharp""", """#!fsharp\n""").Replace("""```""","""#!markdown\n""")
            let outfile = folderPath + link.[link.LastIndexOf("/") + 1..].Replace(".md", ".dib") 
            printfn "Writing file: %s\n\n%s\n\n" outfile dibDocument
            File.WriteAllText(outfile, dibDocument)
                
        else
            let folder = link.[link.LastIndexOf("/")..]
            let folderUrl = "https://github.com" + link
            printfn "Folder: %s " folderUrl
            let topics = HtmlDocument.Load(folderUrl).CssSelect(listSelector)
            let links = topics |> List.map(fun a -> (a.AttributeValue("href")))
            ReadDocs links.[0..2] folder
            // printfn "Error fetching: %s" link

ReadDocs links.[0..2] ""
