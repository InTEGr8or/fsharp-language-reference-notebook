#!markdown

# Reference Cells

<em>Reference cells</em> are storage locations that enable you to create mutable values with reference semantics.

## Syntax

#!fsharp

ref expression


#!markdown

## Remarks

You use the `ref` operator before a value to create a new reference cell that encapsulates the value. You can then change the underlying value because it is mutable.

A reference cell holds an actual value; it is not just an address. When you create a reference cell by using the `ref` operator, you create a copy of the underlying value as an encapsulated mutable value.

You can dereference a reference cell by using the `!` (bang) operator.

The following code example illustrates the declaration and use of reference cells.

#!fsharp

// Declare a reference.
let refVar = ref 6

// Change the value referred to by the reference.
refVar := 50

// Dereference by using the ! operator.
printfn "%d" !refVar


#!markdown

The output is `50`.

Reference cells are instances of the `Ref` generic record type, which is declared as follows.

#!fsharp

type Ref<'a> =
{ mutable contents: 'a }


#!markdown

The type `'a ref` is a synonym for `Ref&lt;'a&gt;`. The compiler and IntelliSense in the IDE display the former for this type, but the underlying definition is the latter.

The `ref` operator creates a new reference cell. The following code is the declaration of the `ref` operator.

#!fsharp

let ref x = { contents = x }


#!markdown

The following table shows the features that are available on the reference cell.

<table class="table"><caption class="visually-hidden">Table 1</caption>
<thead>
<tr>
<th>Operator, member, or field</th>
<th>Description</th>
<th>Type</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
<td>`!` (dereference operator)</td>
<td>Returns the underlying value.</td>
<td>`'a ref -&gt; 'a`</td>
<td>`let (!) r = r.contents`</td>
</tr>
<tr>
<td>`:=` (assignment operator)</td>
<td>Changes the underlying value.</td>
<td>`'a ref -&gt; 'a -&gt; unit`</td>
<td>`let (:=) r x = r.contents &lt;- x`</td>
</tr>
<tr>
<td>`ref` (operator)</td>
<td>Encapsulates a value into a new reference cell.</td>
<td>`'a -&gt; 'a ref`</td>
<td>`let ref x = { contents = x }`</td>
</tr>
<tr>
<td>`Value` (property)</td>
<td>Gets or sets the underlying value.</td>
<td>`unit -&gt; 'a`</td>
<td>`member x.Value = x.contents`</td>
</tr>
<tr>
<td>`contents` (record field)</td>
<td>Gets or sets the underlying value.</td>
<td>`'a`</td>
<td>`let ref x = { contents = x }`</td>
</tr>
</tbody>
</table>

There are several ways to access the underlying value. The value returned by the dereference operator (`!`) is not an assignable value. Therefore, if you are modifying the underlying value, you must use the assignment operator (`:=`) instead.

Both the `Value` property and the `contents` field are assignable values. Therefore, you can use these to either access or change the underlying value, as shown in the following code.

#!fsharp

let xRef : int ref = ref 10

printfn "%d" (xRef.Value)
printfn "%d" (xRef.contents)

xRef.Value <- 11
printfn "%d" (xRef.Value)
xRef.contents <- 12
printfn "%d" (xRef.contents)


#!markdown

The output is as follows.

#!fsharp

10
10
11
12


#!markdown

The field `contents` is provided for compatibility with other versions of ML and will produce a warning during compilation. To disable the warning, use the `--mlcompatibility` compiler option. For more information, see <a href="compiler-options" data-linktype="relative-path">Compiler Options</a>.

C# programmers should know that `ref` in C# is not the same thing as `ref` in F#. The equivalent constructs in F# are <a href="byrefs" data-linktype="relative-path">byrefs</a>, which are a different concept from reference cells.

Values marked as `mutable`may be automatically promoted to `'a ref` if captured by a closure; see <a href="values/" data-linktype="relative-path">Values</a>.

## See also

