# let Bindings

*   <time class="" data-article-date="" aria-label="Article review date" datetime="2016-05-16T00:00:00.000Z" data-article-date-source="ms.date">05/16/2016</time>

*   5 minutes to read

*   *   [
																		![](https://github.com/cartermp.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-teal" aria-hidden="true">c</span>
																	](https://github.com/cartermp "cartermp")

    *   [
																		![](https://github.com/Potapy4.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-red" aria-hidden="true">P</span>
																	](https://github.com/Potapy4 "Potapy4")

    *   [
																		![](https://github.com/nschonni.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-blue" aria-hidden="true">n</span>
																	](https://github.com/nschonni "nschonni")

    *   [
																		![](https://github.com/mairaw.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-teal" aria-hidden="true">m</span>
																	](https://github.com/mairaw "mairaw")

    *   [
																		![](https://github.com/nemrism.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-red" aria-hidden="true">n</span>
																	](https://github.com/nemrism "nemrism")

    *   <button aria-label="View all contributors" class="facepile-item-more" title="View all contributors">
																<div class="facepile-item-coin" aria-hidden="true">
																	<span class="facepile-item-coin-text" aria-hidden="true">
																		+1
																	</span>
																</div>
															</button>

								<nav id="center-doc-outline" class="doc-outline is-hidden-desktop" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">

### In this article

1.  [Syntax](#syntax)
2.  [Remarks](#remarks)
3.  [Function Bindings](#function-bindings)
4.  [Type Annotations](#type-annotations)
5.  [let Bindings in Classes](#let-bindings-in-classes)
6.  [Type Parameters in let Bindings](#type-parameters-in-let-bindings)
7.  [Attributes on let Bindings](#attributes-on-let-bindings)
8.  [Scope and Accessibility of Let Bindings](#scope-and-accessibility-of-let-bindings)
9.  [See also](#see-also)</nav>

A *binding* associates an identifier with a value or function. You use the `let` keyword to bind a name to a value or function.

## [](#syntax)Syntax

<div class="codeHeader" id="code-try-0" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-comment">// Binding a value:</span>
    <span class="hljs-keyword">let</span> identifier-<span class="hljs-keyword">or</span>-pattern [: <span class="hljs-class"><span class="hljs-keyword">type</span>] </span>=expressionbody-expression
    <span class="hljs-comment">// Binding a function value:</span>
    <span class="hljs-keyword">let</span> identifier parameter-list [: <span class="hljs-keyword">return</span>-<span class="hljs-class"><span class="hljs-keyword">type</span> ] </span>=expressionbody-expression
    </span>
    ```

## [](#remarks)Remarks

The `let` keyword is used in binding expressions to define values or function values for one or more names. The simplest form of the `let` expression binds a name to a simple value, as follows.

<div class="codeHeader" id="code-try-1" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>
    </span>
    ```

If you separate the expression from the identifier by using a new line, you must indent each line of the expression, as in the following code.

<div class="codeHeader" id="code-try-2" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> someVeryLongIdentifier =
        <span class="hljs-comment">// Note indentation below.</span>
        <span class="hljs-number">3</span> * <span class="hljs-number">4</span> + <span class="hljs-number">5</span> * <span class="hljs-number">6</span>
    </span>
    ```

Instead of just a name, a pattern that contains names can be specified, for example, a tuple, as shown in the following code.

<div class="codeHeader" id="code-try-3" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> i, j, k = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
    </span>
    ```

The *body-expression* is the expression in which the names are used. The body expression appears on its own line, indented to line up exactly with the first character in the `let` keyword:

<div class="codeHeader" id="code-try-4" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> result =

        <span class="hljs-keyword">let</span> i, j, k = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)

        <span class="hljs-comment">// Body expression:</span>
        i + <span class="hljs-number">2</span>*j + <span class="hljs-number">3</span>*k
    </span>
    ```

A `let` binding can appear at the module level, in the definition of a class type, or in local scopes, such as in a function definition. A `let` binding at the top level in a module or in a class type does not need to have a body expression, but at other scope levels, the body expression is required. The bound names are usable after the point of definition, but not at any point before the `let` binding appears, as is illustrated in the following code.

<div class="codeHeader" id="code-try-5" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-comment">// Error:</span>
    printfn <span class="hljs-string">"%d"</span> x
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">100</span>
    <span class="hljs-comment">// OK:</span>
    printfn <span class="hljs-string">"%d"</span> x
    </span>
    ```

## [](#function-bindings)Function Bindings

Function bindings follow the rules for value bindings, except that function bindings include the function name and the parameters, as shown in the following code.

<div class="codeHeader" id="code-try-6" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> function1 a =
        a + <span class="hljs-number">1</span>
    </span>
    ```

In general, parameters are patterns, such as a tuple pattern:

<div class="codeHeader" id="code-try-7" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> function2 (a, b) = a + b
    </span>
    ```

A `let` binding expression evaluates to the value of the last expression. Therefore, in the following code example, the value of `result` is computed from `100 * function3 (1, 2)`, which evaluates to `300`.

<div class="codeHeader" id="code-try-8" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> result =
        <span class="hljs-keyword">let</span> function3 (a, b) = a + b
        <span class="hljs-number">100</span> * function3 (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
    </span>
    ```

For more information, see [Functions](./).

## [](#type-annotations)Type Annotations

You can specify types for parameters by including a colon (:) followed by a type name, all enclosed in parentheses. You can also specify the type of the return value by appending the colon and type after the last parameter. The full type annotations for `function1`, with integers as the parameter types, would be as follows.

<div class="codeHeader" id="code-try-9" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> function1 (a: int) : int = a + <span class="hljs-number">1</span>
    </span>
    ```

When there are no explicit type parameters, type inference is used to determine the types of parameters of functions. This can include automatically generalizing the type of a parameter to be generic.

For more information, see [Automatic Generalization](../generics/automatic-generalization) and [Type Inference](../type-inference).

## [](#let-bindings-in-classes)let Bindings in Classes

A `let` binding can appear in a class type but not in a structure or record type. To use a let binding in a class type, the class must have a primary constructor. Constructor parameters must appear after the type name in the class definition. A `let` binding in a class type defines private fields and members for that class type and, together with `do` bindings in the type, forms the code for the primary constructor for the type. The following code examples show a class `MyClass` with private fields `field1` and `field2`.

<div class="codeHeader" id="code-try-10" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">MyClass</span></span>(a) =
        <span class="hljs-keyword">let</span> field1 = a
        <span class="hljs-keyword">let</span> field2 = <span class="hljs-string">"text"</span>
        <span class="hljs-keyword">do</span> printfn <span class="hljs-string">"%d %s"</span> field1 field2
        <span class="hljs-keyword">member</span> this.F input =
            printfn <span class="hljs-string">"Field1 %d Field2 %s Input %A"</span> field1 field2 input
    </span>
    ```

The scopes of `field1` and `field2` are limited to the type in which they are declared. For more information, see [`let` Bindings in Classes](../members/let-bindings-in-classes) and [Classes](../classes).

## [](#type-parameters-in-let-bindings)Type Parameters in let Bindings

A `let` binding at the module level, in a type, or in a computation expression can have explicit type parameters. A let binding in an expression, such as within a function definition, cannot have type parameters. For more information, see [Generics](../generics/).

## [](#attributes-on-let-bindings)Attributes on let Bindings

Attributes can be applied to top-level `let` bindings in a module, as shown in the following code.

<div class="codeHeader" id="code-try-11" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-meta">[<Obsolete>]</span>
    <span class="hljs-keyword">let</span> function1 x y = x + y
    </span>
    ```

## [](#scope-and-accessibility-of-let-bindings)Scope and Accessibility of Let Bindings

The scope of an entity declared with a let binding is limited to the portion of the containing scope (such as a function, module, file or class) after the binding appears. Therefore, it can be said that a let binding introduces a name into a scope. In a module, a let-bound value or function is accessible to clients of a module as long as the module is accessible, since the let bindings in a module are compiled into public functions of the module. By contrast, let bindings in a class are private to the class.

Normally, functions in modules must be qualified by the name of the module when used by client code. For example, if a module `Module1` has a function `function1`, users would specify `Module1.function1` to refer to the function.

Users of a module may use an import declaration to make the functions within that module available for use without being qualified by the module name. In the example just mentioned, users of the module can in that case open the module by using the import declaration open `Module1` and thereafter refer to `function1` directly.

<div class="codeHeader" id="code-try-12" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">module</span> Module1 =
        <span class="hljs-keyword">let</span> function1 x = x + <span class="hljs-number">1.0</span>

    <span class="hljs-keyword">module</span> Module2 =
        <span class="hljs-keyword">let</span> function2 x =
            Module1.function1 x

    <span class="hljs-keyword">open</span> Module1

    <span class="hljs-keyword">let</span> function3 x =
        function1 x
    </span>
    ```

Some modules have the attribute [RequireQualifiedAccess](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-core-requirequalifiedaccessattribute.html), which means that the functions that they expose must be qualified with the name of the module. For example, the F# List module has this attribute.

For more information on modules and access control, see [Modules](../modules) and [Access Control](../access-control).

## [](#see-also)See also

*   [Functions](./)

*   [`let` Bindings in Classes](../members/let-bindings-in-classes)

						