# Functions

*   <time class="" data-article-date="" aria-label="Article review date" datetime="2016-05-16T00:00:00.000Z" data-article-date-source="ms.date">05/16/2016</time>

*   9 minutes to read

*   *   [
																		![](https://github.com/cartermp.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-teal" aria-hidden="true">c</span>
																	](https://github.com/cartermp "cartermp")

    *   [
																		![](https://github.com/nxtn.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-red" aria-hidden="true">n</span>
																	](https://github.com/nxtn "nxtn")

    *   [
																		![](https://github.com/gewarren.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-blue" aria-hidden="true">g</span>
																	](https://github.com/gewarren "gewarren")

    *   [
																		![](https://github.com/Potapy4.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-teal" aria-hidden="true">P</span>
																	](https://github.com/Potapy4 "Potapy4")

    *   [
																		![](https://github.com/nschonni.png?size=32)
																		<span class="facepile-item-coin-text durable-image-fallback facepile-item-red" aria-hidden="true">n</span>
																	](https://github.com/nschonni "nschonni")

    *   <button aria-label="View all contributors" class="facepile-item-more" title="View all contributors">
																<div class="facepile-item-coin" aria-hidden="true">
																	<span class="facepile-item-coin-text" aria-hidden="true">
																		+6
																	</span>
																</div>
															</button>

								<nav id="center-doc-outline" class="doc-outline is-hidden-desktop" data-bi-name="intopic toc" role="navigation" aria-label="Article Outline">

### In this article

1.  [Syntax](#syntax)
2.  [Remarks](#remarks)
3.  [Scope](#scope)
4.  [Function Bodies](#function-bodies)
5.  [Return Values](#return-values)
6.  [Calling a Function](#calling-a-function)
7.  [Partial Application of Arguments](#partial-application-of-arguments)
8.  [Recursive Functions](#recursive-functions)
9.  [Function Values](#function-values)
10.  [Lambda Expressions](#lambda-expressions)
11.  [Function Composition and Pipelining](#function-composition-and-pipelining)
12.  [Overloading Functions](#overloading-functions)
13.  [See also](#see-also)</nav>

Functions are the fundamental unit of program execution in any programming language. As in other languages, an F# function has a name, can have parameters and take arguments, and has a body. F# also supports functional programming constructs such as treating functions as values, using unnamed functions in expressions, composition of functions to form new functions, curried functions, and the implicit definition of functions by way of the partial application of function arguments.

You define functions by using the `let` keyword, or, if the function is recursive, the `let rec` keyword combination.

## [](#syntax)Syntax

<div class="codeHeader" id="code-try-0" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-comment">// Non-recursive function definition.</span>
    <span class="hljs-keyword">let</span> [<span class="hljs-keyword">inline</span>] <span class="hljs-keyword">function</span>-name parameter-list [ : <span class="hljs-keyword">return</span>-<span class="hljs-class"><span class="hljs-keyword">type</span> ] </span>= <span class="hljs-keyword">function</span>-body
    <span class="hljs-comment">// Recursive function definition.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> <span class="hljs-keyword">function</span>-name parameter-list = recursive-<span class="hljs-keyword">function</span>-body
    </span>
    ```

## [](#remarks)Remarks

The *function-name* is an identifier that represents the function. The *parameter-list* consists of successive parameters that are separated by spaces. You can specify an explicit type for each parameter, as described in the Parameters section. If you do not specify a specific argument type, the compiler attempts to infer the type from the function body. The *function-body* consists of an expression. The expression that makes up the function body is typically a compound expression consisting of a number of expressions that culminate in a final expression that is the return value. The *return-type* is a colon followed by a type and is optional. If you do not specify the type of the return value explicitly, the compiler determines the return type from the final expression.

A simple function definition resembles the following:

<div class="codeHeader" id="code-try-1" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> f x = x + <span class="hljs-number">1</span>
    </span>
    ```

In the previous example, the function name is `f`, the argument is `x`, which has type `int`, the function body is `x + 1`, and the return value is of type `int`.

Functions can be marked `inline`. For information about `inline`, see [Inline Functions](inline-functions).

## [](#scope)Scope

At any level of scope other than module scope, it is not an error to reuse a value or function name. If you reuse a name, the name declared later shadows the name declared earlier. However, at the top level scope in a module, names must be unique. For example, the following code produces an error when it appears at module scope, but not when it appears inside a function:

<div class="codeHeader" id="code-try-2" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> list1 = [ <span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>]
    <span class="hljs-comment">// Error: duplicate definition.</span>
    <span class="hljs-keyword">let</span> list1 = []
    <span class="hljs-keyword">let</span> function1 =
       <span class="hljs-keyword">let</span> list1 = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>]
       <span class="hljs-keyword">let</span> list1 = []
       list1
    </span>
    ```

But the following code is acceptable at any level of scope:

<div class="codeHeader" id="code-try-3" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> list1 = [ <span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>]
    <span class="hljs-keyword">let</span> sumPlus x =
    <span class="hljs-comment">// OK: inner list1 hides the outer list1.</span>
       <span class="hljs-keyword">let</span> list1 = [<span class="hljs-number">1</span>; <span class="hljs-number">5</span>; <span class="hljs-number">10</span>]
       x + List.sum list1
    </span>
    ```

### [](#parameters)Parameters

Names of parameters are listed after the function name. You can specify a type for a parameter, as shown in the following example:

<div class="codeHeader" id="code-try-4" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> f (x : int) = x + <span class="hljs-number">1</span>
    </span>
    ```

If you specify a type, it follows the name of the parameter and is separated from the name by a colon. If you omit the type for the parameter, the parameter type is inferred by the compiler. For example, in the following function definition, the argument `x` is inferred to be of type `int` because 1 is of type `int`.

<div class="codeHeader" id="code-try-5" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> f x = x + <span class="hljs-number">1</span>
    </span>
    ```

However, the compiler will attempt to make the function as generic as possible. For example, note the following code:

<div class="codeHeader" id="code-try-6" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> f x = (x, x)
    </span>
    ```

The function creates a tuple from one argument of any type. Because the type is not specified, the function can be used with any argument type. For more information, see [Automatic Generalization](../generics/automatic-generalization).

## [](#function-bodies)Function Bodies

A function body can contain definitions of local variables and functions. Such variables and functions are in scope in the body of the current function but not outside it. When you have the lightweight syntax option enabled, you must use indentation to indicate that a definition is in a function body, as shown in the following example:

<div class="codeHeader" id="code-try-7" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> cylinderVolume radius length =
        <span class="hljs-comment">// Define a local value pi.</span>
        <span class="hljs-keyword">let</span> pi = <span class="hljs-number">3.14159</span>
        length * pi * radius * radius
    </span>
    ```

For more information, see [Code Formatting Guidelines](../../style-guide/formatting) and [Verbose Syntax](../verbose-syntax).

## [](#return-values)Return Values

The compiler uses the final expression in a function body to determine the return value and type. The compiler might infer the type of the final expression from previous expressions. In the function `cylinderVolume`, shown in the previous section, the type of `pi` is determined from the type of the literal `3.14159` to be `float`. The compiler uses the type of `pi` to determine the type of the expression `h * pi * r * r` to be `float`. Therefore, the overall return type of the function is `float`.

To specify the return value explicitly, write the code as follows:

<div class="codeHeader" id="code-try-8" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> cylinderVolume radius length : float =
       <span class="hljs-comment">// Define a local value pi.</span>
       <span class="hljs-keyword">let</span> pi = <span class="hljs-number">3.14159</span>
       length * pi * radius * radius
    </span>
    ```

As the code is written above, the compiler applies **float** to the entire function; if you mean to apply it to the parameter types as well, use the following code:

<div class="codeHeader" id="code-try-9" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> cylinderVolume (radius : float) (length : float) : float
    </span>
    ```

## [](#calling-a-function)Calling a Function

You call functions by specifying the function name followed by a space and then any arguments separated by spaces. For example, to call the function **cylinderVolume** and assign the result to the value **vol**, you write the following code:

<div class="codeHeader" id="code-try-10" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> vol = cylinderVolume <span class="hljs-number">2.0</span> <span class="hljs-number">3.0</span>
    </span>
    ```

## [](#partial-application-of-arguments)Partial Application of Arguments

If you supply fewer than the specified number of arguments, you create a new function that expects the remaining arguments. This method of handling arguments is referred to as *currying* and is a characteristic of functional programming languages like F#. For example, suppose you are working with two sizes of pipe: one has a radius of **2.0** and the other has a radius of **3.0**. You could create functions that determine the volume of pipe as follows:

<div class="codeHeader" id="code-try-11" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> smallPipeRadius = <span class="hljs-number">2.0</span>
    <span class="hljs-keyword">let</span> bigPipeRadius = <span class="hljs-number">3.0</span>

    <span class="hljs-comment">// These define functions that take the length as a remaining</span>
    <span class="hljs-comment">// argument:</span>

    <span class="hljs-keyword">let</span> smallPipeVolume = cylinderVolume smallPipeRadius
    <span class="hljs-keyword">let</span> bigPipeVolume = cylinderVolume bigPipeRadius
    </span>
    ```

You would then supply the additional argument as needed for various lengths of pipe of the two different sizes:

<div class="codeHeader" id="code-try-12" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> length1 = <span class="hljs-number">30.0</span>
    <span class="hljs-keyword">let</span> length2 = <span class="hljs-number">40.0</span>
    <span class="hljs-keyword">let</span> smallPipeVol1 = smallPipeVolume length1
    <span class="hljs-keyword">let</span> smallPipeVol2 = smallPipeVolume length2
    <span class="hljs-keyword">let</span> bigPipeVol1 = bigPipeVolume length1
    <span class="hljs-keyword">let</span> bigPipeVol2 = bigPipeVolume length2
    </span>
    ```

## [](#recursive-functions)Recursive Functions

*Recursive functions* are functions that call themselves. They require that you specify the **rec** keyword following the **let** keyword. Invoke the recursive function from within the body of the function just as you would invoke any function call. The following recursive function computes the *n*<sup>th</sup> Fibonacci number. The Fibonacci number sequence has been known since antiquity and is a sequence in which each successive number is the sum of the previous two numbers in the sequence.

<div class="codeHeader" id="code-try-13" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> fib n = <span class="hljs-keyword">if</span> n < <span class="hljs-number">2</span> <span class="hljs-keyword">then</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> fib (n - <span class="hljs-number">1</span>) + fib (n - <span class="hljs-number">2</span>)
    </span>
    ```

Some recursive functions might overflow the program stack or perform inefficiently if you do not write them with care and with awareness of special techniques, such as the use of accumulators and continuations.

## [](#function-values)Function Values

In F#, all functions are considered values; in fact, they are known as *function values*. Because functions are values, they can be used as arguments to other functions or in other contexts where values are used. Following is an example of a function that takes a function value as an argument:

<div class="codeHeader" id="code-try-14" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> apply1 (transform : int -> int ) y = transform y
    </span>
    ```

You specify the type of a function value by using the `->` token. On the left side of this token is the type of the argument, and on the right side is the return value. In the previous example, `apply1` is a function that takes a function `transform` as an argument, where `transform` is a function that takes an integer and returns another integer. The following code shows how to use `apply1`:

<div class="codeHeader" id="code-try-15" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> increment x = x + <span class="hljs-number">1</span>

    <span class="hljs-keyword">let</span> result1 = apply1 increment <span class="hljs-number">100</span>
    </span>
    ```

The value of `result` will be 101 after the previous code runs.

Multiple arguments are separated by successive `->` tokens, as shown in the following example:

<div class="codeHeader" id="code-try-16" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> apply2 ( f: int -> int -> int) x y = f x y

    <span class="hljs-keyword">let</span> mul x y = x * y

    <span class="hljs-keyword">let</span> result2 = apply2 mul <span class="hljs-number">10</span> <span class="hljs-number">20</span>
    </span>
    ```

The result is 200.

## [](#lambda-expressions)Lambda Expressions

A *lambda expression* is an unnamed function. In the previous examples, instead of defining named functions **increment** and **mul**, you could use lambda expressions as follows:

<div class="codeHeader" id="code-try-17" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> result3 = apply1 (<span class="hljs-keyword">fun</span> x -> x + <span class="hljs-number">1</span>) <span class="hljs-number">100</span>

    <span class="hljs-keyword">let</span> result4 = apply2 (<span class="hljs-keyword">fun</span> x y -> x * y ) <span class="hljs-number">10</span> <span class="hljs-number">20</span>
    </span>
    ```

You define lambda expressions by using the `fun` keyword. A lambda expression resembles a function definition, except that instead of the `=` token, the `->` token is used to separate the argument list from the function body. As in a regular function definition, the argument types can be inferred or specified explicitly, and the return type of the lambda expression is inferred from the type of the last expression in the body. For more information, see [Lambda Expressions: The `fun` Keyword](lambda-expressions-the-fun-keyword).

## [](#function-composition-and-pipelining)Function Composition and Pipelining

Functions in F# can be composed from other functions. The composition of two functions **function1** and **function2** is another function that represents the application of **function1** followed the application of **function2**:

<div class="codeHeader" id="code-try-18" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> function1 x = x + <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> function2 x = x * <span class="hljs-number">2</span>
    <span class="hljs-keyword">let</span> h = function1 >> function2
    <span class="hljs-keyword">let</span> result5 = h <span class="hljs-number">100</span>
    </span>
    ```

The result is 202.

Pipelining enables function calls to be chained together as successive operations. Pipelining works as follows:

<div class="codeHeader" id="code-try-19" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-keyword">let</span> result = <span class="hljs-number">100</span> |> function1 |> function2
    </span>
    ```

The result is again 202.

The composition operators take two functions and return a function; by contrast, the pipeline operators take a function and an argument and return a value. The following code example shows the difference between the pipeline and composition operators by showing the differences in the function signatures and usage.

<div class="codeHeader" id="code-try-20" data-bi-name="code-header"><span class="language">F#</span><button type="button" class="action position-relative" data-bi-name="copy" aria-label="Copy code">
				<span class="icon">
					<span class="docon docon-edit-copy" role="presentation"></span>
				</span>
				<span>Copy</span>
				<div class="successful-copy-alert position-absolute right-0 top-0 left-0 bottom-0 display-flex align-items-center justify-content-center has-text-success-invert has-background-success is-transparent" aria-hidden="true">
					<span class="icon font-size-l">
						<span class="docon docon-check-mark" role="presentation"></span>
					</span>
				</div>
			</button></div>

```
    <span><span class="hljs-comment">// Function composition and pipeline operators compared.</span>

    <span class="hljs-keyword">let</span> addOne x = x + <span class="hljs-number">1</span>
    <span class="hljs-keyword">let</span> timesTwo x = <span class="hljs-number">2</span> * x

    <span class="hljs-comment">// Composition operator</span>
    <span class="hljs-comment">// ( >> ) : ('T1 -> 'T2) -> ('T2 -> 'T3) -> 'T1 -> 'T3</span>
    <span class="hljs-keyword">let</span> Compose2 = addOne >> timesTwo

    <span class="hljs-comment">// Backward composition operator</span>
    <span class="hljs-comment">// ( << ) : ('T2 -> 'T3) -> ('T1 -> 'T2) -> 'T1 -> 'T3</span>
    <span class="hljs-keyword">let</span> Compose1 = addOne << timesTwo

    <span class="hljs-comment">// Result is 5</span>
    <span class="hljs-keyword">let</span> result1 = Compose1 <span class="hljs-number">2</span>

    <span class="hljs-comment">// Result is 6</span>
    <span class="hljs-keyword">let</span> result2 = Compose2 <span class="hljs-number">2</span>

    <span class="hljs-comment">// Pipelining</span>
    <span class="hljs-comment">// Pipeline operator</span>
    <span class="hljs-comment">// ( |> ) : 'T1 -> ('T1 -> 'U) -> 'U</span>
    <span class="hljs-keyword">let</span> Pipeline2 x = addOne x |> timesTwo

    <span class="hljs-comment">// Backward pipeline operator</span>
    <span class="hljs-comment">// ( <| ) : ('T -> 'U) -> 'T -> 'U</span>
    <span class="hljs-keyword">let</span> Pipeline1 x = addOne <| timesTwo x

    <span class="hljs-comment">// Result is 5</span>
    <span class="hljs-keyword">let</span> result3 = Pipeline1 <span class="hljs-number">2</span>

    <span class="hljs-comment">// Result is 6</span>
    <span class="hljs-keyword">let</span> result4 = Pipeline2 <span class="hljs-number">2</span>
    </span>
    ```

## [](#overloading-functions)Overloading Functions

You can overload methods of a type but not functions. For more information, see [Methods](../members/methods).

## [](#see-also)See also

*   [Values](../values/)

*   [F# Language Reference](../)

						