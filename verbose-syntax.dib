#!markdown

---
title: Verbose Syntax
description: Learn the difference between verbose and lightweight syntax in the F# programming language.
ms.date: 05/16/2016
---
# Verbose Syntax

There are two forms of syntax available for many constructs in the F# language: *verbose syntax* and *lightweight syntax*. The verbose syntax is not as commonly used, but has the advantage of being less sensitive to indentation. The lightweight syntax is shorter and uses indentation to signal the beginning and end of constructs, rather than additional keywords like `begin`, `end`, `in`, and so on. The default syntax is the lightweight syntax. This topic describes the syntax for F# constructs when lightweight syntax is not enabled. Verbose syntax is always enabled, so even if you enable lightweight syntax, you can still use verbose syntax for some constructs. You can disable lightweight syntax by using the `#light "off"` directive.

## Table of Constructs

The following table shows the lightweight and verbose syntax for F# language constructs in contexts where there is a difference between the two forms. In this table, angle brackets (&lt;&gt;) enclose user-supplied syntax elements. Refer to the documentation for each language construct for more detailed information about the syntax used within these constructs.

<table>
<tr>
<th>Language construct</th>
<th>Lightweight syntax</th>
<th>Verbose syntax</th>
</tr>
<tr>
<td>
compound expressions
</td>
<td>

#!fsharp
<expression1>
<expression2>
#!markdown

</td><td>

#!fsharp
<expression1>; <expression2>
#!markdown

</td>
</tr>
<tr><td>

nested `let` bindings

</td><td>

#!fsharp
let f x =
    let a = 1
    let b = 2
    x + a + b
#!markdown

</td><td>

#!fsharp
let f x =
    let a = 1 in
    let b = 2 in
    x + a + b
#!markdown

</td>
</tr>
<tr><td>
code block
</td><td>

#!fsharp
(
    <expression1>
    <expression2>
)
#!markdown

</td><td>

#!fsharp
begin
    <expression1>;
    <expression2>;
end
#!markdown

</td>
</tr>
<tr><td>
`for...do`
</td><td>

#!fsharp
for counter = start to finish do
    ...
#!markdown

</td><td>

#!fsharp
for counter = start to finish do
    ...
done
#!markdown

</td>
</tr>
<tr><td>
`while...do`
</td><td>

#!fsharp
while <condition> do
    ...
#!markdown

</td><td>

#!fsharp
while <condition> do
    ...
done
#!markdown

</td>
</tr>
<tr><td>
`for...in`
</td><td>

#!fsharp
for var in start .. finish do
    ...
#!markdown

</td><td>

#!fsharp
for var in start .. finish do
    ...
done
#!markdown

</td>
</tr>
<tr><td>
`do`
</td><td>

#!fsharp
do
    ...
#!markdown

</td><td>

#!fsharp
do
    ...
in
#!markdown

</td>
</tr>
<tr><td>record
</td><td>

#!fsharp
type <record-name> =
    {
        <field-declarations>
    }
    <value-or-member-definitions>
#!markdown

</td><td>

#!fsharp
type <record-name> =
    {
        <field-declarations>
    }
    with
        <value-or-member-definitions>
    end
#!markdown

</td>
</tr>
<tr><td>class
</td><td>

#!fsharp
type <class-name>(<params>) =
    ...
#!markdown

</td><td>

#!fsharp
type <class-name>(<params>) =
    class
        ...
    end
#!markdown

</td>
</tr>
<tr><td>structure</td><td>

#!fsharp
[<StructAttribute>]
type <structure-name> =
    ...
#!markdown

</td><td>

#!fsharp
type <structure-name> =
    struct
        ...
    end
#!markdown

</td>
</tr>
<tr><td>discriminated union</td><td>

#!fsharp
type <union-name> =
    | ...
    | ...
    ...
    <value-or-member definitions>
#!markdown

</td><td>

#!fsharp
type <union-name> =
    | ...
    | ...
    ...
    with
        <value-or-member-definitions>
    end
#!markdown

</td>
</tr>
<tr><td>interface</td><td>

#!fsharp
type <interface-name> =
    ...
#!markdown

</td><td>

#!fsharp
type <interface-name> =
    interface
        ...
    end
#!markdown

</td>
</tr>
<tr><td>object expression</td><td>

#!fsharp
{ new <type-name>
    with
        <value-or-member-definitions>
        <interface-implementations>
}
#!markdown

</td><td>

#!fsharp
{ new <type-name>
    with
        <value-or-member-definitions>
    end
    <interface-implementations>
}
#!markdown

</td>
</tr>
<tr><td>interface implementation</td><td>

#!fsharp
interface <interface-name>
    with
        <value-or-member-definitions>
#!markdown

</td><td>

#!fsharp
interface <interface-name>
    with
        <value-or-member-definitions>
    end
#!markdown

</td>
</tr>
<tr><td>type extension</td><td>

#!fsharp
type <type-name>
    with
        <value-or-member-definitions>
#!markdown

</td><td>

#!fsharp
type <type-name>
    with
        <value-or-member-definitions>
    end
#!markdown

</td>
</tr>
<tr><td>module</td><td>

#!fsharp
module <module-name> =
    ...
#!markdown

</td><td>

#!fsharp
module <module-name> =
    begin
        ...
    end
#!markdown

</td>
</tr>
</table>

## See also

- [F# Language Reference](index.md)
- [Compiler Directives](compiler-directives.md)
- [Code Formatting Guidelines](../style-guide/formatting.md)
